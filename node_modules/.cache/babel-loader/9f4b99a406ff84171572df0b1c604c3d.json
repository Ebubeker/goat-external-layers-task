{"remainingRequest":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js??ref--13-0!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/IsochroneUtils.js","dependencies":[{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/IsochroneUtils.js","mtime":1657636289867},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js","mtime":1657636581481},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js","mtime":1657636581253}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport _toConsumableArray from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport { linearInterpolation, getClosest, interpolateColor } from \"../utils/Helpers\";\nimport i18n from \"../../src/plugins/i18n\";\n/**\n * Util class for Isochrone Calculation\n */\n\nvar IsochroneUtils = {\n  getCalculationFeatures: function getCalculationFeatures(calculation, IsochroneLayer) {\n    var data = calculation.data;\n    var isochroneFeatures = [];\n\n    if (data) {\n      data.forEach(function (isochrone) {\n        var id = isochrone.id;\n        var feature = IsochroneLayer.getSource().getFeatureById(id);\n\n        if (feature) {\n          isochroneFeatures.push(feature);\n        }\n      });\n    }\n\n    return isochroneFeatures;\n  },\n  getCalculationPoisObject: function getCalculationPoisObject(isochroneFeatures) {\n    var obj = {};\n\n    if (isochroneFeatures.length > 0) {\n      isochroneFeatures.forEach(function (isochrone) {\n        var modus = isochrone.get(\"modus\");\n        var time = isochrone.get(\"step\");\n        var pois = isochrone.get(\"reached_opportunities\");\n\n        if (!obj[modus]) {\n          obj[modus] = {};\n        }\n\n        obj[modus][time] = pois;\n      });\n    }\n\n    return obj;\n  },\n  getMultiIsochroneTableData: function getMultiIsochroneTableData(isochroneFeatures) {\n    var multiIsochroneTableData = [];\n    isochroneFeatures.forEach(function (feature) {\n      var obj = {\n        isochrone: \"\".concat(IsochroneUtils.getIsochroneAliasFromKey(feature.get(\"modus\")), \" - \").concat(Math.round(feature.get(\"step\") / 60), \" min\")\n      };\n      var populationObj = feature.get(\"reached_opportunities\");\n\n      if (feature.get(\"reached_opportunities\").name || feature.get(\"reached_opportunities\").name == \"polygon\") {\n        //Multi-isochrone is created using draw\n        obj.studyArea = \"-- (Draw)\";\n        obj.population = populationObj.total_population;\n        obj.reachPopulation = populationObj.reached_population;\n        obj.shared = obj.population == 0 || obj.reachPopulation == 0 ? \"-\" : \"\".concat((obj.reachPopulation / obj.population * 100).toFixed(1), \"%\");\n        multiIsochroneTableData.push(obj);\n      } else {\n        //Multi-isochrone is created from study-area\n        Object.keys(populationObj).forEach(function (currentStudyAreaKey) {\n          var currentStudyArea = populationObj[currentStudyAreaKey];\n          var _obj = {\n            studyArea: currentStudyArea.name,\n            population: currentStudyArea.total_population,\n            reachPopulation: currentStudyArea.reached_population\n          };\n\n          if (_obj.population && _obj.reachPopulation) {\n            _obj.shared = \"\".concat((_obj.reachPopulation / _obj.population * 100).toFixed(1), \"%\");\n          }\n\n          multiIsochroneTableData.push(Object.assign(_obj, obj));\n        });\n      }\n    });\n    return multiIsochroneTableData;\n  },\n  getIsochroneAliasFromKey: function getIsochroneAliasFromKey(key) {\n    var alias = key ? i18n.t(\"isochrones.mode.\".concat(key.toLowerCase())) : key;\n    return alias;\n  },\n  getInterpolatedColor: function getInterpolatedColor(lowestValue, highestValue, value, color) {\n    var colorKeys = Object.keys(color).map(function (n) {\n      return parseInt(n, 10);\n    }); //====//\n    // x1 lowest step value TODO: get this dynamically from the options\n    // x2 highest step value  TODO: get this dynamically from the options\n    // y1 lowest color key code\n    // y2 highest color key code\n    // x current step value\n    // Interpolates step values down to color key length\n\n    var interpolatedValue = linearInterpolation(lowestValue, highestValue, colorKeys[0], _toConsumableArray(colorKeys).pop(), value // isochrone step or cost\n    );\n    var interpolatedColor; // Find if the interpolated value exists in colors key, if not find two closest values.\n\n    if (colorKeys.includes(interpolatedValue)) {\n      // No interpolation\n      interpolatedColor = color[interpolatedValue];\n    } else {\n      // Interpolate using factor\n      var closestKeys = getClosest(colorKeys, interpolatedValue); //ex [3,4] color object keys\n\n      var lowerColor = color[closestKeys[0]];\n      var upperColor = color[closestKeys[1]];\n      var factor = interpolatedValue - closestKeys[0]; // factor goes from 0 => 1\n\n      interpolatedColor = interpolateColor(lowerColor, upperColor, factor);\n    }\n\n    return interpolatedColor;\n  }\n};\nexport default IsochroneUtils;",{"version":3,"sources":["/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/IsochroneUtils.js"],"names":["linearInterpolation","getClosest","interpolateColor","i18n","IsochroneUtils","getCalculationFeatures","calculation","IsochroneLayer","data","isochroneFeatures","forEach","isochrone","id","feature","getSource","getFeatureById","push","getCalculationPoisObject","obj","length","modus","get","time","pois","getMultiIsochroneTableData","multiIsochroneTableData","getIsochroneAliasFromKey","Math","round","populationObj","name","studyArea","population","total_population","reachPopulation","reached_population","shared","toFixed","Object","keys","currentStudyAreaKey","currentStudyArea","_obj","assign","key","alias","t","toLowerCase","getInterpolatedColor","lowestValue","highestValue","value","color","colorKeys","map","n","parseInt","interpolatedValue","pop","interpolatedColor","includes","closestKeys","lowerColor","upperColor","factor"],"mappings":"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","sourcesContent":["import {\n  linearInterpolation,\n  getClosest,\n  interpolateColor\n} from \"../utils/Helpers\";\nimport i18n from \"../../src/plugins/i18n\";\n/**\n * Util class for Isochrone Calculation\n */\n\nconst IsochroneUtils = {\n  getCalculationFeatures: function getCalculationFeatures(\n    calculation,\n    IsochroneLayer\n  ) {\n    let data = calculation.data;\n    let isochroneFeatures = [];\n    if (data) {\n      data.forEach(isochrone => {\n        let id = isochrone.id;\n        let feature = IsochroneLayer.getSource().getFeatureById(id);\n        if (feature) {\n          isochroneFeatures.push(feature);\n        }\n      });\n    }\n\n    return isochroneFeatures;\n  },\n  getCalculationPoisObject: function getCalculationPoisObject(\n    isochroneFeatures\n  ) {\n    let obj = {};\n    if (isochroneFeatures.length > 0) {\n      isochroneFeatures.forEach(isochrone => {\n        let modus = isochrone.get(\"modus\");\n        let time = isochrone.get(\"step\");\n        let pois = isochrone.get(\"reached_opportunities\");\n        if (!obj[modus]) {\n          obj[modus] = {};\n        }\n        obj[modus][time] = pois;\n      });\n    }\n    return obj;\n  },\n  getMultiIsochroneTableData: function getMultiIsochroneTableData(\n    isochroneFeatures\n  ) {\n    let multiIsochroneTableData = [];\n    isochroneFeatures.forEach(feature => {\n      let obj = {\n        isochrone: `${IsochroneUtils.getIsochroneAliasFromKey(\n          feature.get(\"modus\")\n        )} - ${Math.round(feature.get(\"step\") / 60)} min`\n      };\n      const populationObj = feature.get(\"reached_opportunities\");\n      if (\n        feature.get(\"reached_opportunities\").name ||\n        feature.get(\"reached_opportunities\").name == \"polygon\"\n      ) {\n        //Multi-isochrone is created using draw\n        obj.studyArea = \"-- (Draw)\";\n        obj.population = populationObj.total_population;\n        obj.reachPopulation = populationObj.reached_population;\n\n        obj.shared =\n          obj.population == 0 || obj.reachPopulation == 0\n            ? \"-\"\n            : `${((obj.reachPopulation / obj.population) * 100).toFixed(1)}%`;\n\n        multiIsochroneTableData.push(obj);\n      } else {\n        //Multi-isochrone is created from study-area\n\n        Object.keys(populationObj).forEach(currentStudyAreaKey => {\n          const currentStudyArea = populationObj[currentStudyAreaKey];\n          const _obj = {\n            studyArea: currentStudyArea.name,\n            population: currentStudyArea.total_population,\n            reachPopulation: currentStudyArea.reached_population\n          };\n          if (_obj.population && _obj.reachPopulation) {\n            _obj.shared = `${(\n              (_obj.reachPopulation / _obj.population) *\n              100\n            ).toFixed(1)}%`;\n          }\n          multiIsochroneTableData.push(Object.assign(_obj, obj));\n        });\n      }\n    });\n    return multiIsochroneTableData;\n  },\n  getIsochroneAliasFromKey(key) {\n    let alias = key ? i18n.t(`isochrones.mode.${key.toLowerCase()}`) : key;\n    return alias;\n  },\n  getInterpolatedColor(lowestValue, highestValue, value, color) {\n    const colorKeys = Object.keys(color).map(n => parseInt(n, 10));\n    //====//\n    // x1 lowest step value TODO: get this dynamically from the options\n    // x2 highest step value  TODO: get this dynamically from the options\n    // y1 lowest color key code\n    // y2 highest color key code\n    // x current step value\n    // Interpolates step values down to color key length\n    const interpolatedValue = linearInterpolation(\n      lowestValue,\n      highestValue,\n      colorKeys[0],\n      [...colorKeys].pop(),\n      value // isochrone step or cost\n    );\n    let interpolatedColor;\n    // Find if the interpolated value exists in colors key, if not find two closest values.\n    if (colorKeys.includes(interpolatedValue)) {\n      // No interpolation\n      interpolatedColor = color[interpolatedValue];\n    } else {\n      // Interpolate using factor\n      const closestKeys = getClosest(colorKeys, interpolatedValue); //ex [3,4] color object keys\n      const lowerColor = color[closestKeys[0]];\n      const upperColor = color[closestKeys[1]];\n      const factor = interpolatedValue - closestKeys[0]; // factor goes from 0 => 1\n      interpolatedColor = interpolateColor(lowerColor, upperColor, factor);\n    }\n\n    return interpolatedColor;\n  }\n};\n\nexport default IsochroneUtils;\n"]}]}
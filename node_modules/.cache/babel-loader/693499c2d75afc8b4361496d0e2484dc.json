{"remainingRequest":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js??ref--13-0!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/MapUtils.js","dependencies":[{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/MapUtils.js","mtime":1657636289867},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js","mtime":1657636581481},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js","mtime":1657636581253}],"contextDependencies":[],"result":["import Projection from \"ol/proj/Projection\";\nimport TileGrid from \"ol/tilegrid/TileGrid\";\nimport Feature from \"ol/Feature\";\nimport Point from \"ol/geom/Point\";\nimport Vector from \"ol/source/Vector\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport { getTopLeft, getBottomLeft } from \"ol/extent\";\nimport WKT from \"ol/format/WKT\";\nimport { getArea } from \"ol/sphere\";\n\nvar geobuf = require(\"geobuf\");\n\nvar Pbf = require(\"pbf\");\n\nimport TurfBuffer from \"@turf/buffer\";\nexport function isWithinVisibleScales(scale, maxScale, minScale) {\n  if (maxScale || minScale) {\n    // Alter 1: maxscale and minscale\n    if (maxScale && minScale) {\n      if (scale > maxScale && scale < minScale) {\n        return true;\n      }\n    } else if (maxScale) {\n      // Alter 2: only maxscale\n      if (scale > maxScale) {\n        return true;\n      }\n    } else if (minScale) {\n      // Alter 3: only minscale\n      if (scale < minScale) {\n        return true;\n      }\n    }\n  } else {\n    // Alter 4: no scale limit\n    return true;\n  }\n\n  return false;\n}\nexport function customProjection(projectionCode, extent) {\n  return new Projection({\n    code: projectionCode,\n    extent: extent\n  });\n}\nexport function tileGrid(settings) {\n  var defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var tileGridSettings = Object.assign({}, defaultSettings, settings);\n  var extent = tileGridSettings.extent;\n  tileGridSettings.origin = tileGridSettings.alignBottomLeft === false ? getTopLeft(extent) : getBottomLeft(extent);\n  return new TileGrid(tileGridSettings);\n}\nexport function checkZoomChange(resolution, currentResolution) {\n  if (resolution !== currentResolution) {\n    return true;\n  }\n\n  return false;\n}\nexport function createPointFeature(coordinate, style) {\n  var feature = new Feature({\n    geometry: new Point(coordinate)\n  });\n  feature.setStyle(style);\n  return feature;\n}\nexport function geojsonToFeature(obj, options) {\n  var featureObj = obj;\n\n  while (Array.isArray(featureObj)) {\n    featureObj = featureObj[0];\n  }\n\n  if (typeof obj === \"string\") {\n    featureObj = JSON.parse(obj);\n  } else if (!featureObj.features) {\n    featureObj.features = [];\n  }\n\n  var vectorSource = new Vector({\n    features: new GeoJSON().readFeatures(featureObj, options)\n  });\n  return vectorSource.getFeatures();\n}\nexport function geobufToFeatures(obj, config) {\n  var geojson = geobuf.decode(new Pbf(obj));\n  return geojsonToFeature(geojson, config);\n}\nexport function featuresToGeojson(features, featureProjection, dataProjection) {\n  var options = {\n    featureProjection: featureProjection\n  };\n\n  if (dataProjection) {\n    options.dataProjection = dataProjection;\n  }\n\n  var format = new GeoJSON(options);\n  var json = format.writeFeatures(features);\n  return json;\n}\nexport function geometryToWKT(geometry, featureProjection, dataProjection) {\n  var options = {\n    featureProjection: featureProjection\n  };\n\n  if (dataProjection) {\n    options.dataProjection = dataProjection;\n  }\n\n  var format = new WKT(options);\n  var wktGeom = format.writeGeometry(geometry);\n  return wktGeom;\n}\nexport function wktToFeature(wkt, srsName) {\n  var format = new WKT();\n  var feature = format.readFeature(wkt, {\n    dataProjection: srsName,\n    featureProjection: srsName\n  });\n  return feature;\n}\nexport function getCenter(geometry) {\n  var type = geometry.getType();\n  var center;\n\n  switch (type) {\n    case \"Polygon\":\n      center = geometry.getInteriorPoint().getCoordinates();\n      break;\n\n    case \"MultiPolygon\":\n      center = geometry.getInteriorPoints().getFirstCoordinate();\n      break;\n\n    case \"Point\":\n      center = geometry.getCoordinates();\n      break;\n\n    case \"MultiPoint\":\n      center = geometry[0].getCoordinates();\n      break;\n\n    case \"LineString\":\n      center = geometry.getCoordinateAt(0.5);\n      break;\n\n    case \"MultiLineString\":\n      center = geometry.getLineStrings()[0].getCoordinateAt(0.5);\n      break;\n\n    case \"Circle\":\n      center = geometry.getCenter();\n      break;\n\n    default:\n      break;\n  }\n\n  return center;\n}\nexport function OlBuffer(featureCollection, bufferDistance) {\n  var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"meters\";\n  var buffer = TurfBuffer(featureCollection, bufferDistance, {\n    units: units\n  });\n  return buffer;\n}\nexport function getPolygonArea(polygon) {\n  var type = polygon.getType();\n  var output = \"\";\n\n  if (type === \"Polygon\" || type === \"MultiPolygon\") {\n    var area = getArea(polygon);\n    output = \"\".concat(Math.round(area / 1000000 * 100) / 100, \" km\\xB2\");\n  }\n\n  return output;\n}\nexport function resolutionToScale(resolution, projection) {\n  var dpi = 25.4 / 0.28;\n  var mpu = projection.getMetersPerUnit();\n  var scale = resolution * mpu * 39.37 * dpi;\n  scale = Math.round(scale);\n  return scale;\n}\nexport function scaleToResolution(scale, projection) {\n  var dpi = 25.4 / 0.28;\n  var mpu = projection.getMetersPerUnit();\n  var resolution = scale / (mpu * 39.37 * dpi);\n  return resolution;\n}\nexport function flyTo(destination, map, done) {\n  var duration = 2000;\n  var view = map.getView();\n  var zoom = view.getZoom();\n  var parts = 2;\n  var called = false;\n\n  function callback(complete) {\n    --parts;\n\n    if (called) {\n      return;\n    }\n\n    if (parts === 0 || !complete) {\n      called = true;\n      done(complete);\n    }\n  }\n\n  view.animate({\n    center: destination,\n    duration: duration\n  }, callback);\n  view.animate({\n    zoom: zoom - 1,\n    duration: duration / 2\n  }, {\n    zoom: zoom,\n    duration: duration / 2\n  }, callback);\n}\nexport function checkFeaturesEquality(feature1, feature2) {\n  var formatWKT = new WKT();\n  var feature1WKT = formatWKT.writeGeometry(feature1.getGeometry());\n  var feature2WKT = formatWKT.writeGeometry(feature2.getGeometry());\n\n  if (feature1WKT === feature2WKT) {\n    return true;\n  } else {\n    return false;\n  }\n}",{"version":3,"sources":["/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/MapUtils.js"],"names":["Projection","TileGrid","Feature","Point","Vector","GeoJSON","getTopLeft","getBottomLeft","WKT","getArea","geobuf","require","Pbf","TurfBuffer","isWithinVisibleScales","scale","maxScale","minScale","customProjection","projectionCode","extent","code","tileGrid","settings","defaultSettings","tileGridSettings","Object","assign","origin","alignBottomLeft","checkZoomChange","resolution","currentResolution","createPointFeature","coordinate","style","feature","geometry","setStyle","geojsonToFeature","obj","options","featureObj","Array","isArray","JSON","parse","features","vectorSource","readFeatures","getFeatures","geobufToFeatures","config","geojson","decode","featuresToGeojson","featureProjection","dataProjection","format","json","writeFeatures","geometryToWKT","wktGeom","writeGeometry","wktToFeature","wkt","srsName","readFeature","getCenter","type","getType","center","getInteriorPoint","getCoordinates","getInteriorPoints","getFirstCoordinate","getCoordinateAt","getLineStrings","OlBuffer","featureCollection","bufferDistance","units","buffer","getPolygonArea","polygon","output","area","Math","round","resolutionToScale","projection","dpi","mpu","getMetersPerUnit","scaleToResolution","flyTo","destination","map","done","duration","view","getView","zoom","getZoom","parts","called","callback","complete","animate","checkFeaturesEquality","feature1","feature2","formatWKT","feature1WKT","getGeometry","feature2WKT"],"mappings":"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","sourcesContent":["import Projection from \"ol/proj/Projection\";\nimport TileGrid from \"ol/tilegrid/TileGrid\";\nimport Feature from \"ol/Feature\";\nimport Point from \"ol/geom/Point\";\nimport Vector from \"ol/source/Vector\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport { getTopLeft, getBottomLeft } from \"ol/extent\";\nimport WKT from \"ol/format/WKT\";\nimport { getArea } from \"ol/sphere\";\nconst geobuf = require(\"geobuf\");\nconst Pbf = require(\"pbf\");\nimport TurfBuffer from \"@turf/buffer\";\n\nexport function isWithinVisibleScales(scale, maxScale, minScale) {\n  if (maxScale || minScale) {\n    // Alter 1: maxscale and minscale\n    if (maxScale && minScale) {\n      if (scale > maxScale && scale < minScale) {\n        return true;\n      }\n    } else if (maxScale) {\n      // Alter 2: only maxscale\n      if (scale > maxScale) {\n        return true;\n      }\n    } else if (minScale) {\n      // Alter 3: only minscale\n      if (scale < minScale) {\n        return true;\n      }\n    }\n  } else {\n    // Alter 4: no scale limit\n    return true;\n  }\n  return false;\n}\n\nexport function customProjection(projectionCode, extent) {\n  return new Projection({\n    code: projectionCode,\n    extent\n  });\n}\n\nexport function tileGrid(settings, defaultSettings = {}) {\n  const tileGridSettings = Object.assign({}, defaultSettings, settings);\n  const extent = tileGridSettings.extent;\n  tileGridSettings.origin =\n    tileGridSettings.alignBottomLeft === false\n      ? getTopLeft(extent)\n      : getBottomLeft(extent);\n  return new TileGrid(tileGridSettings);\n}\n\nexport function checkZoomChange(resolution, currentResolution) {\n  if (resolution !== currentResolution) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function createPointFeature(coordinate, style) {\n  const feature = new Feature({\n    geometry: new Point(coordinate)\n  });\n  feature.setStyle(style);\n  return feature;\n}\n\nexport function geojsonToFeature(obj, options) {\n  let featureObj = obj;\n  while (Array.isArray(featureObj)) {\n    featureObj = featureObj[0];\n  }\n  if (typeof obj === \"string\") {\n    featureObj = JSON.parse(obj);\n  } else if (!featureObj.features) {\n    featureObj.features = [];\n  }\n  const vectorSource = new Vector({\n    features: new GeoJSON().readFeatures(featureObj, options)\n  });\n  return vectorSource.getFeatures();\n}\n\nexport function geobufToFeatures(obj, config) {\n  const geojson = geobuf.decode(new Pbf(obj));\n  return geojsonToFeature(geojson, config);\n}\n\nexport function featuresToGeojson(features, featureProjection, dataProjection) {\n  const options = { featureProjection };\n  if (dataProjection) {\n    options.dataProjection = dataProjection;\n  }\n  const format = new GeoJSON(options);\n  const json = format.writeFeatures(features);\n  return json;\n}\n\nexport function geometryToWKT(geometry, featureProjection, dataProjection) {\n  const options = { featureProjection };\n  if (dataProjection) {\n    options.dataProjection = dataProjection;\n  }\n  const format = new WKT(options);\n  const wktGeom = format.writeGeometry(geometry);\n  return wktGeom;\n}\n\nexport function wktToFeature(wkt, srsName) {\n  const format = new WKT();\n  const feature = format.readFeature(wkt, {\n    dataProjection: srsName,\n    featureProjection: srsName\n  });\n  return feature;\n}\n\nexport function getCenter(geometry) {\n  const type = geometry.getType();\n  let center;\n  switch (type) {\n    case \"Polygon\":\n      center = geometry.getInteriorPoint().getCoordinates();\n      break;\n    case \"MultiPolygon\":\n      center = geometry.getInteriorPoints().getFirstCoordinate();\n      break;\n    case \"Point\":\n      center = geometry.getCoordinates();\n      break;\n    case \"MultiPoint\":\n      center = geometry[0].getCoordinates();\n      break;\n    case \"LineString\":\n      center = geometry.getCoordinateAt(0.5);\n      break;\n    case \"MultiLineString\":\n      center = geometry.getLineStrings()[0].getCoordinateAt(0.5);\n      break;\n    case \"Circle\":\n      center = geometry.getCenter();\n      break;\n    default:\n      break;\n  }\n  return center;\n}\n\nexport function OlBuffer(featureCollection, bufferDistance, units = \"meters\") {\n  const buffer = TurfBuffer(featureCollection, bufferDistance, {\n    units: units\n  });\n  return buffer;\n}\n\nexport function getPolygonArea(polygon) {\n  const type = polygon.getType();\n  let output = \"\";\n  if (type === \"Polygon\" || type === \"MultiPolygon\") {\n    const area = getArea(polygon);\n    output = `${Math.round((area / 1000000) * 100) / 100} km²`;\n  }\n  return output;\n}\n\nexport function resolutionToScale(resolution, projection) {\n  const dpi = 25.4 / 0.28;\n  const mpu = projection.getMetersPerUnit();\n  let scale = resolution * mpu * 39.37 * dpi;\n  scale = Math.round(scale);\n  return scale;\n}\n\nexport function scaleToResolution(scale, projection) {\n  const dpi = 25.4 / 0.28;\n  const mpu = projection.getMetersPerUnit();\n  const resolution = scale / (mpu * 39.37 * dpi);\n  return resolution;\n}\n\nexport function flyTo(destination, map, done) {\n  const duration = 2000;\n  const view = map.getView();\n  const zoom = view.getZoom();\n  let parts = 2;\n  var called = false;\n  function callback(complete) {\n    --parts;\n    if (called) {\n      return;\n    }\n    if (parts === 0 || !complete) {\n      called = true;\n      done(complete);\n    }\n  }\n  view.animate(\n    {\n      center: destination,\n      duration: duration\n    },\n    callback\n  );\n  view.animate(\n    {\n      zoom: zoom - 1,\n      duration: duration / 2\n    },\n    {\n      zoom: zoom,\n      duration: duration / 2\n    },\n    callback\n  );\n}\n\nexport function checkFeaturesEquality(feature1, feature2) {\n  var formatWKT = new WKT();\n  var feature1WKT = formatWKT.writeGeometry(feature1.getGeometry());\n  var feature2WKT = formatWKT.writeGeometry(feature2.getGeometry());\n  if (feature1WKT === feature2WKT) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"]}]}
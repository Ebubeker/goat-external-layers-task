{"remainingRequest":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js??ref--13-0!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/Layer.js","dependencies":[{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/Layer.js","mtime":1657636289867},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js","mtime":1657636581481},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js","mtime":1657636581253}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport _toConsumableArray from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/web.dom.iterable\";\nimport { Group as LayerGroup } from \"ol/layer.js\";\nimport olLayerLayer from \"ol/layer/Layer.js\";\nimport olLayerImage from \"ol/layer/Image.js\";\nimport olLayerVector from \"ol/layer/Vector.js\";\nimport { appendParams as olUriAppendParams } from \"ol/uri.js\";\nimport UrlUtil from \"./Url\";\nimport { geojsonToFeature } from \"./MapUtils\";\nimport http from \"../services/http\";\nimport store from \"../store/index\";\n\nvar geobuf = require(\"geobuf\");\n\nvar Pbf = require(\"pbf\");\n/**\n * Util for OL layers\n */\n\n/**\n * Returns a set of map layers which matches the given key value pair.\n *\n * @param {String} key - Key to filter layers\n * @param {Object} value - Value to filter layers\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base[]} Array of matching layers\n */\n\n\nexport function getLayersBy(key, value, olMap) {\n  if (!olMap) {\n    return [];\n  }\n\n  var layerMatches = [];\n  olMap.getLayers().forEach(function (layer) {\n    if (layer.get(key) === value) {\n      layerMatches.push(layer);\n    }\n  });\n  return layerMatches;\n}\n/**\n * Returns OL Layer type.\n *\n * @param  {ol.layer.Base} Object OL layer\n */\n\nexport function getLayerType(layer) {\n  var layerType;\n\n  if (layer instanceof olLayerImage) {\n    layerType = \"WMS\";\n  } else if (layer instanceof olLayerVector) {\n    layerType = \"WFS\";\n  }\n\n  return layerType;\n}\n/**\n * Returns a map layer with the given LID (Layer ID)\n *\n * @param  {String} lid    The LID of the layer to query\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base} The OL layer instance or undefined\n */\n\nexport function getLayerByLid(lid, olMap) {\n  return getLayersBy(\"lid\", lid, olMap)[0];\n}\n/**\n * Returns all map layers excluding from group layer\n *\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base[]} Array of all map layers\n */\n\nexport function getAllChildLayers(olMap) {\n  var allLayers = [];\n  olMap.getLayers().getArray().forEach(function (layer) {\n    if (layer instanceof LayerGroup) {\n      var layers = layer.getLayers().getArray();\n      allLayers.push.apply(allLayers, _toConsumableArray(layers));\n    } else {\n      allLayers.push(layer);\n    }\n  });\n  return allLayers;\n}\n/**\n * Zooms to the given layer's extent.\n * Will only work if the layer has kind of vector source.\n *\n * @param  {ol.layer.Base} vecLayer OL vector layer\n * @param  {ol.Map} olMap           The map to perform the zoom on\n */\n\nexport function zoomToLayerExtent(vecLayer, olMap) {\n  if (!vecLayer || !vecLayer.getSource().getExtent || !olMap) {\n    return;\n  }\n\n  var extent = vecLayer.getSource().getExtent();\n  olMap.getView().fit(extent);\n}\n/**\n * Get an array of all layers in a group. The group can contain multiple levels\n * of others groups.\n * @param {import(\"ol/layer/Base.js\").default} layer The base layer, mostly a group of layers.\n * @return {Array<import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>>} Layers.\n */\n\nexport function getFlatLayers(layer) {\n  if (layer instanceof LayerGroup) {\n    var sublayers =\n    /** @type {import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>[]} */\n    layer.getLayers().getArray();\n    var hasGroupLayer = sublayers.some(function (sublayer) {\n      return sublayer instanceof LayerGroup;\n    });\n\n    if (!hasGroupLayer) {\n      return sublayers.slice();\n    }\n  }\n\n  return getFlatLayers_(layer, [], undefined);\n}\n/**\n * Get an array of all layers in a group. The group can contain multiple levels\n * of others groups. When we flatten a group, we get the child layers.\n * If opacity is defined on the group, this value is lost.\n * Computed opacity is a custom 'back-up' value that contains\n * the calculated value of all ancestors and the given layer.\n * @param {import(\"ol/layer/Base.js\").default} layer The base layer, mostly a group of layers.\n * @param {olLayerLayer<import('ol/source/Source.js').default>[]} array An array to add layers.\n * @param {number|undefined} computedOpacity Opacity inherited from ancestor layer groups.\n * @return {olLayerLayer<import('ol/source/Source.js').default>[]} Layers.\n * @private\n */\n\nexport function getFlatLayers_(layer, array, computedOpacity) {\n  var opacity = layer.getOpacity();\n\n  if (computedOpacity !== undefined) {\n    computedOpacity *= opacity;\n  } else {\n    computedOpacity = opacity;\n  }\n\n  if (layer instanceof LayerGroup) {\n    var sublayers = layer.getLayers();\n    sublayers.forEach(function (l) {\n      getFlatLayers_(l, array, computedOpacity);\n    });\n  } else if (layer instanceof olLayerLayer) {\n    if (!array.includes(layer)) {\n      layer.set(\"inheritedOpacity\", computedOpacity, true);\n      array.push(layer);\n    }\n  }\n\n  return array;\n}\n/**\n * Gets teh active baselayer if there\n * is one activated otherwise it will return an empty array.\n * @param  {ol.Map} olMap           The map to perform the search on.\n * @return {Array<import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>>} Layers.\n */\n\nexport function getActiveBaseLayer(map) {\n  var activeBaselayer = map.getLayers().getArray().filter(function (groupLayer) {\n    return groupLayer.get(\"name\") === \"backgroundLayers\";\n  })[0].getLayers().getArray().filter(function (layer) {\n    return layer.getVisible() === true;\n  });\n  return activeBaselayer;\n}\n/**\n * Get the WMS legend URL for the given node.\n * @param {string|undefined} url The base url of the wms service.\n * @param {string} layerName The name of a wms layer.\n * @param {number=} opt_scale A scale.\n * @param {string=} opt_legendRule rule parameters to add to the returned URL.\n * @param {number=} opt_legendWidth the legend width.\n * @param {number=} opt_legendHeight the legend height.\n * @param {string=} opt_servertype the OpenLayers server type.\n * @param {number=} opt_dpi the DPI.\n * @param {number[]=} opt_bbox the bbox.\n * @param {string=} opt_srs The projection code.\n * @param {Object<string, string>=} opt_additionalQueryString Additional query string parameters.\n * @return {string|undefined} The legend URL or undefined.\n */\n\nexport function getWMSLegendURL(url, layerName, opt_scale, opt_legendRule, opt_legendWidth, opt_legendHeight, opt_servertype, opt_dpi, opt_bbox, opt_srs, opt_additionalQueryString, opt_language, opt_style) {\n  if (!url) {\n    return undefined;\n  }\n  /** @type {Object<string, string|boolean|number>} */\n\n\n  var queryString = {\n    FORMAT: \"image/png\",\n    TRANSPARENT: true,\n    SERVICE: \"WMS\",\n    VERSION: \"1.1.1\",\n    REQUEST: \"GetLegendGraphic\",\n    LAYER: layerName\n  };\n\n  if (opt_scale !== undefined) {\n    queryString.SCALE = opt_scale;\n  }\n\n  if (opt_language) {\n    queryString.LANGUAGE = opt_language;\n  }\n\n  if (opt_style) {\n    queryString.STYLE = opt_style;\n  }\n\n  if (opt_legendRule !== undefined) {\n    queryString.RULE = opt_legendRule;\n\n    if (opt_legendWidth !== undefined) {\n      queryString.WIDTH = opt_legendWidth;\n    }\n\n    if (opt_legendHeight !== undefined) {\n      queryString.HEIGHT = opt_legendHeight;\n    }\n  }\n\n  if (opt_servertype == \"qgis\") {\n    if (opt_dpi != undefined) {\n      queryString.DPI = opt_dpi;\n    }\n\n    if (opt_bbox != undefined && opt_srs != undefined && opt_scale != undefined && opt_dpi != undefined && opt_legendRule == undefined) {\n      queryString.BBOX = opt_bbox.join(\",\");\n      queryString.SRS = opt_srs;\n      queryString.WIDTH = Math.round((opt_bbox[2] - opt_bbox[0]) / opt_scale * 39.37 * opt_dpi);\n      queryString.HEIGHT = Math.round((opt_bbox[3] - opt_bbox[1]) / opt_scale * 39.37 * opt_dpi);\n    }\n  }\n\n  if (opt_additionalQueryString) {\n    Object.assign(queryString, opt_additionalQueryString);\n  }\n\n  return olUriAppendParams(url, queryString);\n}\n/**\n * Get decscibeFeatureType properties and converts to a json schema for generating dynamic vuetify fields\n * @param {props} decscibeFeatureType json schema\n * @return {object} Vuetify json schema form\n */\n\nexport function mapFeatureTypeProps(props, layerName, layerConf) {\n  var mapping = {\n    string: \"string\",\n    text: \"string\",\n    int: \"integer\",\n    integer: \"integer\",\n    bigint: \"integer\",\n    number: \"number\",\n    numeric: \"number\"\n  };\n  var obj = {\n    $id: \"https://example.com/person.schema.json\",\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    type: \"object\",\n    required: [],\n    properties: {}\n  };\n  props.forEach(function (prop) {\n    var type = mapping[prop.data_type];\n\n    if (type) {\n      obj.properties[prop.column_name] = {\n        type: type,\n        layerName: layerName\n      };\n\n      if (prop.is_nullable === \"NO\") {\n        obj.required.push(prop.column_name);\n      }\n\n      if (!layerConf) return;\n\n      if (layerConf[\"hiddenProps\"] && layerConf[\"hiddenProps\"].includes(prop.column_name)) {\n        obj.properties[prop.column_name][\"x-display\"] = \"hidden\";\n      }\n\n      if (layerConf[\"listValues\"] && layerConf[\"listValues\"][prop.column_name] && Array.isArray(layerConf[\"listValues\"][prop.column_name].values)) {\n        obj.properties[prop.column_name][\"enum\"] = layerConf[\"listValues\"][prop.column_name].values; //Show as autocomplete\n\n        obj.properties[prop.column_name][\"isAutocomplete\"] = true;\n      }\n    }\n  });\n  return obj;\n}\n/**\n * Get the array of pois values\n * @param {poisConfiguration} object pois configuration\n * @return {array} pois key values\n */\n\nexport function getPoisListValues(pois) {\n  var poisListValues = [];\n  pois.forEach(function (category) {\n    var children = category.children;\n    children.forEach(function (pois) {\n      poisListValues.push(pois.value);\n    });\n  });\n  return poisListValues;\n}\n/**\n * Update vector layers query params\n * @param {layer} object map layer\n * @param {key} String Url Key to update\n * @param {value} String\n */\n\nexport function updateLayerUrlQueryParam(layer, queryParams) {\n  var layerSource = layer.getSource();\n  var layerUrl = layerSource.getUrls ? layerSource.getUrls()[0] : layerSource.getUrl();\n  var keys = Object.keys(queryParams);\n\n  if (layerUrl) {\n    keys.forEach(function (key) {\n      var value = queryParams[key];\n      layerUrl = UrlUtil.updateQueryStringParameter(layerUrl, key, value);\n    });\n    layerSource.setUrl(layerUrl);\n  }\n}\n/** Refetch layer features if there is no url */\n\nexport function fetchLayerFeatures(layer, payload) {\n  // Prevent layer to trigger concurrentRequests\n  if (layer.get(\"concurrentRequests\") === false) {\n    layer.set(\"isBusy\", true);\n    store.commit(\"map/INSERT_BUSY_LAYER\", layer);\n  }\n\n  http.post(layer.get(\"url\"), payload, {\n    responseType: \"arraybuffer\"\n  }).then(function (response) {\n    var data = response.data;\n    var geojson = geobuf.decode(new Pbf(data));\n    layer.getSource().clear();\n\n    if (geojson) {\n      var features = geojsonToFeature(geojson, {\n        dataProjection: \"EPSG:4326\",\n        featureProjection: \"EPSG:3857\"\n      });\n      layer.getSource().addFeatures(features);\n    }\n\n    if (layer.get(\"isBusy\")) {\n      setTimeout(function () {\n        layer.set(\"isBusy\", false);\n        store.commit(\"map/REMOVE_BUSY_LAYER\", layer);\n      }, 200);\n    }\n  }).catch(function (error) {\n    if (layer.get(\"isBusy\")) {\n      layer.set(\"isBusy\", false);\n      store.commit(\"map/REMOVE_BUSY_LAYER\", layer);\n    }\n\n    layer.getSource().clear();\n    console.error(\"Error:\", error);\n  });\n}",{"version":3,"sources":["/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/Layer.js"],"names":["Group","LayerGroup","olLayerLayer","olLayerImage","olLayerVector","appendParams","olUriAppendParams","UrlUtil","geojsonToFeature","http","store","geobuf","require","Pbf","getLayersBy","key","value","olMap","layerMatches","getLayers","forEach","layer","get","push","getLayerType","layerType","getLayerByLid","lid","getAllChildLayers","allLayers","getArray","layers","zoomToLayerExtent","vecLayer","getSource","getExtent","extent","getView","fit","getFlatLayers","sublayers","hasGroupLayer","some","sublayer","slice","getFlatLayers_","undefined","array","computedOpacity","opacity","getOpacity","l","includes","set","getActiveBaseLayer","map","activeBaselayer","filter","groupLayer","getVisible","getWMSLegendURL","url","layerName","opt_scale","opt_legendRule","opt_legendWidth","opt_legendHeight","opt_servertype","opt_dpi","opt_bbox","opt_srs","opt_additionalQueryString","opt_language","opt_style","queryString","FORMAT","TRANSPARENT","SERVICE","VERSION","REQUEST","LAYER","SCALE","LANGUAGE","STYLE","RULE","WIDTH","HEIGHT","DPI","BBOX","join","SRS","Math","round","Object","assign","mapFeatureTypeProps","props","layerConf","mapping","string","text","int","integer","bigint","number","numeric","obj","$id","$schema","type","required","properties","prop","data_type","column_name","is_nullable","Array","isArray","values","getPoisListValues","pois","poisListValues","category","children","updateLayerUrlQueryParam","queryParams","layerSource","layerUrl","getUrls","getUrl","keys","updateQueryStringParameter","setUrl","fetchLayerFeatures","payload","commit","post","responseType","then","response","data","geojson","decode","clear","features","dataProjection","featureProjection","addFeatures","setTimeout","catch","error","console"],"mappings":"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","sourcesContent":["import { Group as LayerGroup } from \"ol/layer.js\";\nimport olLayerLayer from \"ol/layer/Layer.js\";\nimport olLayerImage from \"ol/layer/Image.js\";\nimport olLayerVector from \"ol/layer/Vector.js\";\n\nimport { appendParams as olUriAppendParams } from \"ol/uri.js\";\nimport UrlUtil from \"./Url\";\nimport { geojsonToFeature } from \"./MapUtils\";\nimport http from \"../services/http\";\nimport store from \"../store/index\";\n\nconst geobuf = require(\"geobuf\");\nconst Pbf = require(\"pbf\");\n\n/**\n * Util for OL layers\n */\n\n/**\n * Returns a set of map layers which matches the given key value pair.\n *\n * @param {String} key - Key to filter layers\n * @param {Object} value - Value to filter layers\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base[]} Array of matching layers\n */\nexport function getLayersBy(key, value, olMap) {\n  if (!olMap) {\n    return [];\n  }\n\n  let layerMatches = [];\n  olMap.getLayers().forEach(function(layer) {\n    if (layer.get(key) === value) {\n      layerMatches.push(layer);\n    }\n  });\n\n  return layerMatches;\n}\n\n/**\n * Returns OL Layer type.\n *\n * @param  {ol.layer.Base} Object OL layer\n */\nexport function getLayerType(layer) {\n  let layerType;\n  if (layer instanceof olLayerImage) {\n    layerType = \"WMS\";\n  } else if (layer instanceof olLayerVector) {\n    layerType = \"WFS\";\n  }\n  return layerType;\n}\n\n/**\n * Returns a map layer with the given LID (Layer ID)\n *\n * @param  {String} lid    The LID of the layer to query\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base} The OL layer instance or undefined\n */\nexport function getLayerByLid(lid, olMap) {\n  return getLayersBy(\"lid\", lid, olMap)[0];\n}\n\n/**\n * Returns all map layers excluding from group layer\n *\n * @param  {ol.Map} olMap  The OL map to search in\n * @return {ol.layer.Base[]} Array of all map layers\n */\nexport function getAllChildLayers(olMap) {\n  const allLayers = [];\n  olMap\n    .getLayers()\n    .getArray()\n    .forEach(layer => {\n      if (layer instanceof LayerGroup) {\n        const layers = layer.getLayers().getArray();\n        allLayers.push(...layers);\n      } else {\n        allLayers.push(layer);\n      }\n    });\n  return allLayers;\n}\n\n/**\n * Zooms to the given layer's extent.\n * Will only work if the layer has kind of vector source.\n *\n * @param  {ol.layer.Base} vecLayer OL vector layer\n * @param  {ol.Map} olMap           The map to perform the zoom on\n */\nexport function zoomToLayerExtent(vecLayer, olMap) {\n  if (!vecLayer || !vecLayer.getSource().getExtent || !olMap) {\n    return;\n  }\n  const extent = vecLayer.getSource().getExtent();\n  olMap.getView().fit(extent);\n}\n\n/**\n * Get an array of all layers in a group. The group can contain multiple levels\n * of others groups.\n * @param {import(\"ol/layer/Base.js\").default} layer The base layer, mostly a group of layers.\n * @return {Array<import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>>} Layers.\n */\nexport function getFlatLayers(layer) {\n  if (layer instanceof LayerGroup) {\n    const sublayers = /** @type {import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>[]} */ (layer\n      .getLayers()\n      .getArray());\n    const hasGroupLayer = sublayers.some(\n      sublayer => sublayer instanceof LayerGroup\n    );\n    if (!hasGroupLayer) {\n      return sublayers.slice();\n    }\n  }\n\n  return getFlatLayers_(layer, [], undefined);\n}\n\n/**\n * Get an array of all layers in a group. The group can contain multiple levels\n * of others groups. When we flatten a group, we get the child layers.\n * If opacity is defined on the group, this value is lost.\n * Computed opacity is a custom 'back-up' value that contains\n * the calculated value of all ancestors and the given layer.\n * @param {import(\"ol/layer/Base.js\").default} layer The base layer, mostly a group of layers.\n * @param {olLayerLayer<import('ol/source/Source.js').default>[]} array An array to add layers.\n * @param {number|undefined} computedOpacity Opacity inherited from ancestor layer groups.\n * @return {olLayerLayer<import('ol/source/Source.js').default>[]} Layers.\n * @private\n */\nexport function getFlatLayers_(layer, array, computedOpacity) {\n  const opacity = layer.getOpacity();\n  if (computedOpacity !== undefined) {\n    computedOpacity *= opacity;\n  } else {\n    computedOpacity = opacity;\n  }\n  if (layer instanceof LayerGroup) {\n    const sublayers = layer.getLayers();\n    sublayers.forEach(l => {\n      getFlatLayers_(l, array, computedOpacity);\n    });\n  } else if (layer instanceof olLayerLayer) {\n    if (!array.includes(layer)) {\n      layer.set(\"inheritedOpacity\", computedOpacity, true);\n      array.push(layer);\n    }\n  }\n  return array;\n}\n\n/**\n * Gets teh active baselayer if there\n * is one activated otherwise it will return an empty array.\n * @param  {ol.Map} olMap           The map to perform the search on.\n * @return {Array<import(\"ol/layer/Layer.js\").default<import('ol/source/Source.js').default>>} Layers.\n */\n\nexport function getActiveBaseLayer(map) {\n  const activeBaselayer = map\n    .getLayers()\n    .getArray()\n    .filter(groupLayer => {\n      return groupLayer.get(\"name\") === \"backgroundLayers\";\n    })[0]\n    .getLayers()\n    .getArray()\n    .filter(layer => {\n      return layer.getVisible() === true;\n    });\n  return activeBaselayer;\n}\n\n/**\n * Get the WMS legend URL for the given node.\n * @param {string|undefined} url The base url of the wms service.\n * @param {string} layerName The name of a wms layer.\n * @param {number=} opt_scale A scale.\n * @param {string=} opt_legendRule rule parameters to add to the returned URL.\n * @param {number=} opt_legendWidth the legend width.\n * @param {number=} opt_legendHeight the legend height.\n * @param {string=} opt_servertype the OpenLayers server type.\n * @param {number=} opt_dpi the DPI.\n * @param {number[]=} opt_bbox the bbox.\n * @param {string=} opt_srs The projection code.\n * @param {Object<string, string>=} opt_additionalQueryString Additional query string parameters.\n * @return {string|undefined} The legend URL or undefined.\n */\nexport function getWMSLegendURL(\n  url,\n  layerName,\n  opt_scale,\n  opt_legendRule,\n  opt_legendWidth,\n  opt_legendHeight,\n  opt_servertype,\n  opt_dpi,\n  opt_bbox,\n  opt_srs,\n  opt_additionalQueryString,\n  opt_language,\n  opt_style\n) {\n  if (!url) {\n    return undefined;\n  }\n  /** @type {Object<string, string|boolean|number>} */\n  const queryString = {\n    FORMAT: \"image/png\",\n    TRANSPARENT: true,\n    SERVICE: \"WMS\",\n    VERSION: \"1.1.1\",\n    REQUEST: \"GetLegendGraphic\",\n    LAYER: layerName\n  };\n  if (opt_scale !== undefined) {\n    queryString.SCALE = opt_scale;\n  }\n  if (opt_language) {\n    queryString.LANGUAGE = opt_language;\n  }\n  if (opt_style) {\n    queryString.STYLE = opt_style;\n  }\n  if (opt_legendRule !== undefined) {\n    queryString.RULE = opt_legendRule;\n    if (opt_legendWidth !== undefined) {\n      queryString.WIDTH = opt_legendWidth;\n    }\n    if (opt_legendHeight !== undefined) {\n      queryString.HEIGHT = opt_legendHeight;\n    }\n  }\n  if (opt_servertype == \"qgis\") {\n    if (opt_dpi != undefined) {\n      queryString.DPI = opt_dpi;\n    }\n    if (\n      opt_bbox != undefined &&\n      opt_srs != undefined &&\n      opt_scale != undefined &&\n      opt_dpi != undefined &&\n      opt_legendRule == undefined\n    ) {\n      queryString.BBOX = opt_bbox.join(\",\");\n      queryString.SRS = opt_srs;\n      queryString.WIDTH = Math.round(\n        ((opt_bbox[2] - opt_bbox[0]) / opt_scale) * 39.37 * opt_dpi\n      );\n      queryString.HEIGHT = Math.round(\n        ((opt_bbox[3] - opt_bbox[1]) / opt_scale) * 39.37 * opt_dpi\n      );\n    }\n  }\n  if (opt_additionalQueryString) {\n    Object.assign(queryString, opt_additionalQueryString);\n  }\n  return olUriAppendParams(url, queryString);\n}\n\n/**\n * Get decscibeFeatureType properties and converts to a json schema for generating dynamic vuetify fields\n * @param {props} decscibeFeatureType json schema\n * @return {object} Vuetify json schema form\n */\nexport function mapFeatureTypeProps(props, layerName, layerConf) {\n  const mapping = {\n    string: \"string\",\n    text: \"string\",\n    int: \"integer\",\n    integer: \"integer\",\n    bigint: \"integer\",\n    number: \"number\",\n    numeric: \"number\"\n  };\n  let obj = {\n    $id: \"https://example.com/person.schema.json\",\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    type: \"object\",\n    required: [],\n    properties: {}\n  };\n\n  props.forEach(prop => {\n    let type = mapping[prop.data_type];\n    if (type) {\n      obj.properties[prop.column_name] = {\n        type,\n        layerName\n      };\n      if (prop.is_nullable === \"NO\") {\n        obj.required.push(prop.column_name);\n      }\n      if (!layerConf) return;\n      if (\n        layerConf[\"hiddenProps\"] &&\n        layerConf[\"hiddenProps\"].includes(prop.column_name)\n      ) {\n        obj.properties[prop.column_name][\"x-display\"] = \"hidden\";\n      }\n      if (\n        layerConf[\"listValues\"] &&\n        layerConf[\"listValues\"][prop.column_name] &&\n        Array.isArray(layerConf[\"listValues\"][prop.column_name].values)\n      ) {\n        obj.properties[prop.column_name][\"enum\"] =\n          layerConf[\"listValues\"][prop.column_name].values;\n        //Show as autocomplete\n        obj.properties[prop.column_name][\"isAutocomplete\"] = true;\n      }\n    }\n  });\n  return obj;\n}\n\n/**\n * Get the array of pois values\n * @param {poisConfiguration} object pois configuration\n * @return {array} pois key values\n */\nexport function getPoisListValues(pois) {\n  const poisListValues = [];\n\n  pois.forEach(category => {\n    const children = category.children;\n    children.forEach(pois => {\n      poisListValues.push(pois.value);\n    });\n  });\n  return poisListValues;\n}\n\n/**\n * Update vector layers query params\n * @param {layer} object map layer\n * @param {key} String Url Key to update\n * @param {value} String\n */\nexport function updateLayerUrlQueryParam(layer, queryParams) {\n  const layerSource = layer.getSource();\n  let layerUrl = layerSource.getUrls\n    ? layerSource.getUrls()[0]\n    : layerSource.getUrl();\n  const keys = Object.keys(queryParams);\n  if (layerUrl) {\n    keys.forEach(key => {\n      const value = queryParams[key];\n      layerUrl = UrlUtil.updateQueryStringParameter(layerUrl, key, value);\n    });\n    layerSource.setUrl(layerUrl);\n  }\n}\n\n/** Refetch layer features if there is no url */\nexport function fetchLayerFeatures(layer, payload) {\n  // Prevent layer to trigger concurrentRequests\n  if (layer.get(\"concurrentRequests\") === false) {\n    layer.set(\"isBusy\", true);\n    store.commit(\"map/INSERT_BUSY_LAYER\", layer);\n  }\n\n  http\n    .post(layer.get(\"url\"), payload, {\n      responseType: \"arraybuffer\"\n    })\n    .then(response => {\n      const data = response.data;\n      const geojson = geobuf.decode(new Pbf(data));\n      layer.getSource().clear();\n      if (geojson) {\n        const features = geojsonToFeature(geojson, {\n          dataProjection: \"EPSG:4326\",\n          featureProjection: \"EPSG:3857\"\n        });\n        layer.getSource().addFeatures(features);\n      }\n      if (layer.get(\"isBusy\")) {\n        setTimeout(() => {\n          layer.set(\"isBusy\", false);\n          store.commit(\"map/REMOVE_BUSY_LAYER\", layer);\n        }, 200);\n      }\n    })\n    .catch(error => {\n      if (layer.get(\"isBusy\")) {\n        layer.set(\"isBusy\", false);\n        store.commit(\"map/REMOVE_BUSY_LAYER\", layer);\n      }\n      layer.getSource().clear();\n      console.error(\"Error:\", error);\n    });\n}\n"]}]}
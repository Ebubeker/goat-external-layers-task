{"remainingRequest":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js??ref--13-0!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/LegendRenderer.js","dependencies":[{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/LegendRenderer.js","mtime":1657636289867},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js","mtime":1657636581481},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/eslint-loader/index.js","mtime":1657636581253}],"contextDependencies":[],"result":["import _slicedToArray from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\n/** https://github.com/geostyler/geostyler-legend */\nimport { select } from \"d3-selection\";\nimport { boundingExtent } from \"ol/extent\";\nimport OlGeomPoint from \"ol/geom/Point\";\nimport OlGeomPolygon from \"ol/geom/Polygon\";\nimport OlGeomLineString from \"ol/geom/LineString\";\nimport Renderer from \"ol/render/canvas/Immediate\";\nimport { create as createTransform } from \"ol/transform\";\nimport OlStyleParser from \"geostyler-openlayers-parser\";\nvar iconSize = [40, 30];\n/**\n * A class that can be used to render svg legends.\n */\n\nvar LegendRenderer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructs a new legend renderer.\n   * @param {LegendsConfiguration} config the legend configuration\n   */\n  function LegendRenderer(config) {\n    _classCallCheck(this, LegendRenderer);\n\n    _defineProperty(this, \"config\", null);\n\n    this.config = config;\n  }\n  /**\n   * Constructs a legend configuration from a geostyler style object.\n   * @param {Style} style a geostyler style\n   */\n\n\n  _createClass(LegendRenderer, [{\n    key: \"extractConfigFromStyle\",\n    value: function extractConfigFromStyle(style) {\n      var config = {\n        items: [],\n        title: \"\"\n      }; // if (style.name) {\n      //   config.title = style.name;\n      // }\n\n      var translation = this.config.translation.styleTranslation;\n      var currentLocale = this.config.translation.currentLocale;\n      style.rules.forEach(function (rule) {\n        var title = rule.name;\n\n        if (translation && translation[title] && translation[title][currentLocale]) {\n          title = translation[title][currentLocale];\n        }\n\n        config.items.push({\n          title: title,\n          rule: rule\n        });\n      });\n      return config;\n    }\n    /**\n     * Renders a single legend item.\n     * @param {Selection} container the container to append the legend item to\n     * @param {LegendItemConfiguration} item configuration of the legend item\n     * @param {[number, number]} position the current position\n     */\n\n  }, {\n    key: \"renderLegendItem\",\n    value: function renderLegendItem(container, item, position) {\n      var _this$config = this.config,\n          hideRect = _this$config.hideRect,\n          maxColumnHeight = _this$config.maxColumnHeight,\n          maxColumnWidth = _this$config.maxColumnWidth;\n\n      if (item.rule) {\n        container = container.append(\"g\").attr(\"class\", \"legend-item body-2\").attr(\"title\", item.title);\n        var img = this.getRuleIcon(item.rule);\n        return img.then(function (uri) {\n          if (!hideRect) {\n            container.append(\"rect\").attr(\"x\", position[0] + 1).attr(\"y\", position[1]).attr(\"width\", iconSize[0]).attr(\"height\", iconSize[1]).style(\"fill-opacity\", 0).style(\"stroke\", \"gray\");\n          }\n\n          container.append(\"image\").attr(\"x\", position[0] + 1).attr(\"y\", position[1]).attr(\"width\", iconSize[0]).attr(\"height\", iconSize[1]).attr(\"href\", uri);\n          container.append(\"text\").text(item.title).attr(\"x\", position[0] + iconSize[0] + 5).attr(\"y\", position[1] + 20);\n          position[1] += iconSize[1] + 5;\n\n          if (maxColumnHeight && position[1] + iconSize[1] + 5 >= maxColumnHeight) {\n            position[1] = 5;\n            position[0] += maxColumnWidth;\n          }\n        });\n      }\n\n      return undefined;\n    }\n    /**\n     * Shortens the labels if they overflow.\n     * @param {Selection} nodes the legend item group nodes\n     * @param {number} maxWidth the maximum column width\n     */\n\n  }, {\n    key: \"shortenLabels\",\n    value: function shortenLabels(nodes, maxWidth) {\n      nodes.each(function () {\n        var node = select(this);\n        var text = node.select(\"text\");\n\n        if (!(node.node() instanceof SVGElement)) {\n          return;\n        }\n\n        var elem = node.node();\n        var width = elem.getBoundingClientRect().width;\n        var adapted = false;\n\n        while (width > maxWidth) {\n          var str = text.text();\n          str = str.substring(0, str.length - 1);\n          text.text(str);\n          width = elem.getBoundingClientRect().width;\n          adapted = true;\n        }\n\n        if (adapted) {\n          var _str = text.text();\n\n          _str = _str.substring(0, _str.length - 3);\n          text.text(_str + \"...\");\n        }\n      });\n    }\n    /**\n     * Constructs a geometry for rendering a specific symbolizer.\n     * @param {Symbolizer} symbolizer the symbolizer object\n     */\n\n  }, {\n    key: \"getGeometryForSymbolizer\",\n    value: function getGeometryForSymbolizer(symbolizer) {\n      var kind = symbolizer.kind;\n\n      switch (kind) {\n        case \"Mark\":\n        case \"Icon\":\n        case \"Text\":\n          return new OlGeomPoint([iconSize[0] / 2, iconSize[1] / 2]);\n\n        case \"Fill\":\n          return new OlGeomPolygon([[[3, 3], [iconSize[0] - 3, 3], [iconSize[0] - 3, iconSize[1] - 3], [3, iconSize[1] - 3], [3, 3]]]);\n\n        case \"Line\":\n          return new OlGeomLineString([[iconSize[0] / 6, iconSize[1] / 6], [iconSize[0] / 3, iconSize[1] / 3 * 2], [iconSize[0] / 2, iconSize[1] / 3], [iconSize[0] / 6 * 5, iconSize[1] / 6 * 5]]);\n\n        default:\n          return new OlGeomPoint([iconSize[0] / 2, iconSize[1] / 2]);\n      }\n    }\n    /**\n     * Returns a promise resolving to a data uri with the appropriate rule icon.\n     * @param {Object} rule the geostyler rule\n     */\n\n  }, {\n    key: \"getRuleIcon\",\n    value: function getRuleIcon(rule) {\n      var _this = this;\n\n      var canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", \"\".concat(iconSize[0]));\n      canvas.setAttribute(\"height\", \"\".concat(iconSize[1]));\n      var extent = boundingExtent([[0, 0], [iconSize[0], iconSize[1]]]);\n      var pixelRatio = 1;\n      var context = canvas.getContext(\"2d\");\n      var transform = createTransform();\n      var renderer = new Renderer(context, pixelRatio, extent, transform, 0);\n      var geoms = [];\n      rule.symbolizers.forEach(function (symbolizer) {\n        return geoms.push(_this.getGeometryForSymbolizer(symbolizer));\n      });\n      var styleParser = new OlStyleParser();\n      var style = {\n        name: \"\",\n        rules: [{\n          name: \"\",\n          symbolizers: rule.symbolizers\n        }]\n      };\n      var promise = new Promise(function (resolve, reject) {\n        styleParser.writeStyle(style).then(function (olStyle) {\n          var resolveCanvas = function resolveCanvas() {\n            renderer.setStyle(olStyle);\n            geoms.forEach(function (geom) {\n              return renderer.drawGeometry(geom);\n            });\n            resolve(canvas.toDataURL(\"image/png\"));\n          };\n\n          if (olStyle.getImage()) {\n            //Work around for loading image icon if image not available\n            if (!olStyle.getImage().getSize()) {\n              var src = style.rules[0].symbolizers[0].image;\n              olStyle.getImage().getImage().src = src;\n\n              olStyle.getImage().getImage().onload = function () {\n                var height = olStyle.getImage().getImage().height;\n                var width = olStyle.getImage().getImage().width;\n                olStyle.getImage().iconImage_.size_ = [height, width];\n                resolveCanvas();\n                olStyle.getImage().getImage().onload = null;\n              };\n            } else {\n              resolveCanvas();\n            }\n          } else {\n            resolveCanvas();\n          }\n        }).catch(function () {\n          reject();\n        });\n      });\n      return promise;\n    }\n    /**\n     * Render a single legend.\n     * @param {LegendConfiguration} config the legend config\n     * @param {Selection} svg the root node\n     * @param {[number, number]} position the current position\n     */\n\n  }, {\n    key: \"renderLegend\",\n    value: function renderLegend(config, svg, position) {\n      var _this2 = this;\n\n      var container = svg.append(\"g\");\n\n      if (this.config.overflow !== \"auto\" && position[0] !== 0) {\n        var legendHeight = config.items.length * (iconSize[1] + 5) + 20;\n\n        if (legendHeight + position[1] > this.config.maxColumnHeight) {\n          position[0] += this.config.maxColumnWidth;\n          position[1] = 0;\n        }\n      }\n\n      if (config.title) {\n        container.append(\"text\").text(config.title).attr(\"class\", \"legend-title\").attr(\"text-anchor\", \"start\").attr(\"dy\", \"1em\").attr(\"dx\", position[0]);\n        position[1] += 20;\n      }\n\n      return config.items.reduce(function (cur, item) {\n        return cur.then(function () {\n          return _this2.renderLegendItem(svg, item, position);\n        });\n      }, Promise.resolve());\n    }\n    /**\n     * Renders the configured legend.\n     * @param {HTMLElement} parent a node to append the svg to\n     * @return {Promise<void>} a promise resolving once the legend has finished rendering\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(parent) {\n      var _this3 = this;\n\n      var _this$config2 = this.config,\n          styles = _this$config2.styles,\n          configs = _this$config2.configs,\n          _this$config2$size = _slicedToArray(_this$config2.size, 2),\n          width = _this$config2$size[0],\n          height = _this$config2$size[1];\n\n      var legends = [];\n\n      if (styles) {\n        styles.forEach(function (style) {\n          return legends.push(_this3.extractConfigFromStyle(style));\n        });\n      }\n\n      if (configs) {\n        legends.unshift.apply(legends, configs);\n      }\n\n      var svg = select(parent).append(\"svg\").attr(\"viewBox\", \"0 0 \".concat(width, \" \").concat(height)).attr(\"top\", 0).attr(\"left\", 0).attr(\"width\", width).attr(\"height\", height);\n      var position = [0, 0];\n      var promise = legends.reduce(function (cur, legend) {\n        return cur.then(function () {\n          return _this3.renderLegend(legend, svg, position);\n        });\n      }, Promise.resolve());\n      return promise.then(function () {\n        var nodes = svg.selectAll(\"g.legend-item\");\n\n        _this3.shortenLabels(nodes, _this3.config.maxColumnWidth);\n\n        if (!_this3.config.maxColumnHeight) {\n          svg.attr(\"viewBox\", \"0 0 \".concat(width, \" \").concat(position[1])).attr(\"height\", position[1]);\n        }\n      });\n    }\n  }]);\n\n  return LegendRenderer;\n}();\n\nexport default LegendRenderer;",{"version":3,"sources":["/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/utils/LegendRenderer.js"],"names":["select","boundingExtent","OlGeomPoint","OlGeomPolygon","OlGeomLineString","Renderer","create","createTransform","OlStyleParser","iconSize","LegendRenderer","config","style","items","title","translation","styleTranslation","currentLocale","rules","forEach","rule","name","push","container","item","position","hideRect","maxColumnHeight","maxColumnWidth","append","attr","img","getRuleIcon","then","uri","text","undefined","nodes","maxWidth","each","node","SVGElement","elem","width","getBoundingClientRect","adapted","str","substring","length","symbolizer","kind","canvas","document","createElement","setAttribute","extent","pixelRatio","context","getContext","transform","renderer","geoms","symbolizers","getGeometryForSymbolizer","styleParser","promise","Promise","resolve","reject","writeStyle","olStyle","resolveCanvas","setStyle","geom","drawGeometry","toDataURL","getImage","getSize","src","image","onload","height","iconImage_","size_","catch","svg","overflow","legendHeight","reduce","cur","renderLegendItem","parent","styles","configs","size","legends","extractConfigFromStyle","unshift","apply","legend","renderLegend","selectAll","shortenLabels"],"mappings":"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","sourcesContent":["/** https://github.com/geostyler/geostyler-legend */\n\nimport { select } from \"d3-selection\";\nimport { boundingExtent } from \"ol/extent\";\nimport OlGeomPoint from \"ol/geom/Point\";\nimport OlGeomPolygon from \"ol/geom/Polygon\";\nimport OlGeomLineString from \"ol/geom/LineString\";\nimport Renderer from \"ol/render/canvas/Immediate\";\nimport { create as createTransform } from \"ol/transform\";\n\nimport OlStyleParser from \"geostyler-openlayers-parser\";\n\nconst iconSize = [40, 30];\n\n/**\n * A class that can be used to render svg legends.\n */\nclass LegendRenderer {\n  config = null;\n\n  /**\n   * Constructs a new legend renderer.\n   * @param {LegendsConfiguration} config the legend configuration\n   */\n  constructor(config) {\n    this.config = config;\n  }\n\n  /**\n   * Constructs a legend configuration from a geostyler style object.\n   * @param {Style} style a geostyler style\n   */\n  extractConfigFromStyle(style) {\n    const config = {\n      items: [],\n      title: \"\"\n    };\n    // if (style.name) {\n    //   config.title = style.name;\n    // }\n    const translation = this.config.translation.styleTranslation;\n    const currentLocale = this.config.translation.currentLocale;\n    style.rules.forEach(rule => {\n      let title = rule.name;\n      if (\n        translation &&\n        translation[title] &&\n        translation[title][currentLocale]\n      ) {\n        title = translation[title][currentLocale];\n      }\n      config.items.push({\n        title,\n        rule\n      });\n    });\n    return config;\n  }\n\n  /**\n   * Renders a single legend item.\n   * @param {Selection} container the container to append the legend item to\n   * @param {LegendItemConfiguration} item configuration of the legend item\n   * @param {[number, number]} position the current position\n   */\n  renderLegendItem(container, item, position) {\n    const { hideRect, maxColumnHeight, maxColumnWidth } = this.config;\n\n    if (item.rule) {\n      container = container\n        .append(\"g\")\n        .attr(\"class\", \"legend-item body-2\")\n        .attr(\"title\", item.title);\n      const img = this.getRuleIcon(item.rule);\n      return img.then(uri => {\n        if (!hideRect) {\n          container\n            .append(\"rect\")\n            .attr(\"x\", position[0] + 1)\n            .attr(\"y\", position[1])\n            .attr(\"width\", iconSize[0])\n            .attr(\"height\", iconSize[1])\n            .style(\"fill-opacity\", 0)\n            .style(\"stroke\", \"gray\");\n        }\n        container\n          .append(\"image\")\n          .attr(\"x\", position[0] + 1)\n          .attr(\"y\", position[1])\n          .attr(\"width\", iconSize[0])\n          .attr(\"height\", iconSize[1])\n          .attr(\"href\", uri);\n        container\n          .append(\"text\")\n          .text(item.title)\n          .attr(\"x\", position[0] + iconSize[0] + 5)\n          .attr(\"y\", position[1] + 20);\n        position[1] += iconSize[1] + 5;\n        if (\n          maxColumnHeight &&\n          position[1] + iconSize[1] + 5 >= maxColumnHeight\n        ) {\n          position[1] = 5;\n          position[0] += maxColumnWidth;\n        }\n      });\n    }\n    return undefined;\n  }\n\n  /**\n   * Shortens the labels if they overflow.\n   * @param {Selection} nodes the legend item group nodes\n   * @param {number} maxWidth the maximum column width\n   */\n  shortenLabels(nodes, maxWidth) {\n    nodes.each(function() {\n      const node = select(this);\n      const text = node.select(\"text\");\n      if (!(node.node() instanceof SVGElement)) {\n        return;\n      }\n      const elem = node.node();\n      let width = elem.getBoundingClientRect().width;\n      let adapted = false;\n      while (width > maxWidth) {\n        let str = text.text();\n        str = str.substring(0, str.length - 1);\n        text.text(str);\n        width = elem.getBoundingClientRect().width;\n        adapted = true;\n      }\n      if (adapted) {\n        let str = text.text();\n        str = str.substring(0, str.length - 3);\n        text.text(str + \"...\");\n      }\n    });\n  }\n\n  /**\n   * Constructs a geometry for rendering a specific symbolizer.\n   * @param {Symbolizer} symbolizer the symbolizer object\n   */\n  getGeometryForSymbolizer(symbolizer) {\n    const kind = symbolizer.kind;\n    switch (kind) {\n      case \"Mark\":\n      case \"Icon\":\n      case \"Text\":\n        return new OlGeomPoint([iconSize[0] / 2, iconSize[1] / 2]);\n      case \"Fill\":\n        return new OlGeomPolygon([\n          [\n            [3, 3],\n            [iconSize[0] - 3, 3],\n            [iconSize[0] - 3, iconSize[1] - 3],\n            [3, iconSize[1] - 3],\n            [3, 3]\n          ]\n        ]);\n      case \"Line\":\n        return new OlGeomLineString([\n          [iconSize[0] / 6, iconSize[1] / 6],\n          [iconSize[0] / 3, (iconSize[1] / 3) * 2],\n          [iconSize[0] / 2, iconSize[1] / 3],\n          [(iconSize[0] / 6) * 5, (iconSize[1] / 6) * 5]\n        ]);\n      default:\n        return new OlGeomPoint([iconSize[0] / 2, iconSize[1] / 2]);\n    }\n  }\n\n  /**\n   * Returns a promise resolving to a data uri with the appropriate rule icon.\n   * @param {Object} rule the geostyler rule\n   */\n  getRuleIcon(rule) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"width\", `${iconSize[0]}`);\n    canvas.setAttribute(\"height\", `${iconSize[1]}`);\n    const extent = boundingExtent([\n      [0, 0],\n      [iconSize[0], iconSize[1]]\n    ]);\n    const pixelRatio = 1;\n    const context = canvas.getContext(\"2d\");\n    const transform = createTransform();\n    const renderer = new Renderer(context, pixelRatio, extent, transform, 0);\n    const geoms = [];\n    rule.symbolizers.forEach(symbolizer =>\n      geoms.push(this.getGeometryForSymbolizer(symbolizer))\n    );\n\n    const styleParser = new OlStyleParser();\n\n    const style = {\n      name: \"\",\n      rules: [\n        {\n          name: \"\",\n          symbolizers: rule.symbolizers\n        }\n      ]\n    };\n    const promise = new Promise((resolve, reject) => {\n      styleParser\n        .writeStyle(style)\n        .then(olStyle => {\n          const resolveCanvas = function() {\n            renderer.setStyle(olStyle);\n            geoms.forEach(geom => renderer.drawGeometry(geom));\n            resolve(canvas.toDataURL(\"image/png\"));\n          };\n\n          if (olStyle.getImage()) {\n            //Work around for loading image icon if image not available\n            if (!olStyle.getImage().getSize()) {\n              let src = style.rules[0].symbolizers[0].image;\n              olStyle.getImage().getImage().src = src;\n              olStyle.getImage().getImage().onload = () => {\n                let height = olStyle.getImage().getImage().height;\n                let width = olStyle.getImage().getImage().width;\n                olStyle.getImage().iconImage_.size_ = [height, width];\n                resolveCanvas();\n                olStyle.getImage().getImage().onload = null;\n              };\n            } else {\n              resolveCanvas();\n            }\n          } else {\n            resolveCanvas();\n          }\n        })\n        .catch(() => {\n          reject();\n        });\n    });\n    return promise;\n  }\n\n  /**\n   * Render a single legend.\n   * @param {LegendConfiguration} config the legend config\n   * @param {Selection} svg the root node\n   * @param {[number, number]} position the current position\n   */\n  renderLegend(config, svg, position) {\n    const container = svg.append(\"g\");\n    if (this.config.overflow !== \"auto\" && position[0] !== 0) {\n      const legendHeight = config.items.length * (iconSize[1] + 5) + 20;\n      if (legendHeight + position[1] > this.config.maxColumnHeight) {\n        position[0] += this.config.maxColumnWidth;\n        position[1] = 0;\n      }\n    }\n    if (config.title) {\n      container\n        .append(\"text\")\n        .text(config.title)\n        .attr(\"class\", \"legend-title\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"dy\", \"1em\")\n        .attr(\"dx\", position[0]);\n      position[1] += 20;\n    }\n\n    return config.items.reduce((cur, item) => {\n      return cur.then(() => this.renderLegendItem(svg, item, position));\n    }, Promise.resolve());\n  }\n\n  /**\n   * Renders the configured legend.\n   * @param {HTMLElement} parent a node to append the svg to\n   * @return {Promise<void>} a promise resolving once the legend has finished rendering\n   */\n  render(parent) {\n    const {\n      styles,\n      configs,\n      size: [width, height]\n    } = this.config;\n    const legends = [];\n    if (styles) {\n      styles.forEach(style => legends.push(this.extractConfigFromStyle(style)));\n    }\n    if (configs) {\n      legends.unshift.apply(legends, configs);\n    }\n    const svg = select(parent)\n      .append(\"svg\")\n      .attr(\"viewBox\", `0 0 ${width} ${height}`)\n      .attr(\"top\", 0)\n      .attr(\"left\", 0)\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const position = [0, 0];\n\n    const promise = legends.reduce((cur, legend) => {\n      return cur.then(() => this.renderLegend(legend, svg, position));\n    }, Promise.resolve());\n    return promise.then(() => {\n      const nodes = svg.selectAll(\"g.legend-item\");\n      this.shortenLabels(nodes, this.config.maxColumnWidth);\n      if (!this.config.maxColumnHeight) {\n        svg\n          .attr(\"viewBox\", `0 0 ${width} ${position[1]}`)\n          .attr(\"height\", position[1]);\n      }\n    });\n  }\n}\n\nexport default LegendRenderer;\n"]}]}
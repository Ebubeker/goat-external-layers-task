{"remainingRequest":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/components/viewer/print/PrintLegend.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/src/components/viewer/print/PrintLegend.vue","mtime":1657636289859},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/babel-loader/lib/index.js","mtime":1657636581481},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/vuetify-loader/lib/loader.js","mtime":1657636582513},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/cache-loader/dist/cjs.js","mtime":1657636581841},{"path":"/home/ebubeker/Desktop/programming/work tasks/goat/app/client/node_modules/vue-loader/lib/index.js","mtime":1657636582549}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { mapGetters } from \"vuex\";\nimport { EventBus } from \"../../../EventBus\";\nimport { Mapable } from \"../../../mixins/Mapable\";\nimport { getWMSLegendURL } from \"../../../utils/Layer\";\nimport LegendRenderer from \"../../../utils/LegendRenderer\";\nimport { mapFields } from \"vuex-map-fields\";\n\nexport default {\n  mixins: [Mapable],\n  name: \"map-legend\",\n  props: {\n    color: { type: String, default: \"#2BB381\" }\n  },\n  data: () => ({\n    layers: [],\n    panel: [],\n    isMapMounted: false,\n    isRendered: false\n  }),\n  methods: {\n    /**\n     * This function is executed, after the map is bound (see mixins/Mapable)\n     */\n    onMapBound() {\n      const me = this;\n      const allLayers = me.map.getLayers().getArray();\n      me.layers = allLayers.filter(layer => {\n        return (\n          layer.get(\"displayInLegend\") !== false &&\n          layer.get(\"group\") !== \"basemap\"\n        );\n      });\n      this.isMapMounted = true;\n      EventBus.$on(\"openLegend\", () => this.panel.push(0));\n      EventBus.$on(\"closeLegend\", () => (this.panel = []));\n    },\n    getWMSLegendImageUrl(item, layerName) {\n      let layerUrl = item.getSource().getUrl();\n      if (layerUrl.startsWith(\"/\")) {\n        layerUrl = window.location.origin + layerUrl;\n      }\n      const style = item.getSource().getParams().STYLES;\n      const legedUrl = getWMSLegendURL(\n        layerUrl,\n        layerName,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        item.getSource().serverType_,\n        120,\n        undefined,\n        undefined,\n        undefined,\n        this.$i18n.locale,\n        style\n      );\n      return legedUrl;\n    },\n    renderLegend(item, index) {\n      this.$nextTick(() => {\n        const styleObj = this.vectorTileStyles;\n        const name = item.get(\"name\");\n        let styleTranslation = styleObj[name].translation || {};\n        const currentLocale = this.$i18n.locale;\n        if (styleObj[name] && styleObj[name].format === \"geostyler\") {\n          let el = this.$refs[`legend-vector-${index}`];\n          el = el ? el : [];\n          if (el.length) {\n            if (Array.isArray(el) && el.length > 0) {\n              el = el[0];\n            }\n            // Remove existing svg elements on update (Workaround)\n            if (el && el.childNodes.length > 0) {\n              el.removeChild(el.childNodes[0]);\n            }\n            const style = styleObj[name].style;\n            const filteredStyle = this.filterStylesOnActiveMode(style);\n\n            const renderer = new LegendRenderer({\n              maxColumnWidth: 240,\n              overflow: \"auto\",\n              styles: [filteredStyle || style],\n              size: [230, 300],\n              translation: { styleTranslation, currentLocale }\n            });\n            renderer.render(el);\n          }\n        }\n      });\n    },\n    filterStylesOnActiveMode(style) {\n      const styleRules = style.rules;\n      const filteredRules = [];\n      const activeMode = this.calculationMode.active;\n      let newStyle = { ...style };\n      if (Array.isArray(styleRules)) {\n        styleRules.forEach(rule => {\n          if (Array.isArray(rule.filter)) {\n            let showInLegend = true;\n            rule.filter.forEach(filter => {\n              /** FILTER CURRENT MODES. */\n              if (Array.isArray(filter) && filter.includes(\"modus\")) {\n                showInLegend = false;\n                const operator = filter[0];\n                const value = filter[2];\n                if (value === activeMode && operator === \"==\") {\n                  showInLegend = true;\n                } else if (value !== activeMode && operator === \"!=\") {\n                  showInLegend = true;\n                }\n              }\n            });\n            if (showInLegend) filteredRules.push(rule);\n            // Add all other rules in the legend\n          } else {\n            filteredRules.push(rule);\n          }\n        });\n        if (Array.isArray(filteredRules)) {\n          newStyle.rules = filteredRules;\n        }\n        return newStyle;\n      }\n    },\n    layerVisibility(item) {\n      if (\n        (this.map.getView().getResolution() <= item.get(\"maxResolution\") &&\n          item.getVisible() === true &&\n          item.get(\"displayInLayerList\") !== false &&\n          item.get(\"displayInLegend\") !== false &&\n          item.get(\"group\") !== \"backgroundLayers\" &&\n          this.isMapMounted === true &&\n          this.vectorTileStyles) ||\n        item.get(\"name\") == \"study_area_crop\"\n      ) {\n        return true;\n      }\n      return false;\n    }\n  },\n\n  computed: {\n    ...mapGetters(\"app\", {\n      calculationMode: \"calculationMode\"\n    }),\n    ...mapFields(\"map\", {\n      vectorTileStyles: \"vectorTileStyles\"\n    })\n  },\n  watch: {\n    \"calculationMode.active\": function() {\n      this.$forceUpdate();\n    }\n  }\n};\n",{"version":3,"sources":["PrintLegend.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PrintLegend.vue","sourceRoot":"src/components/viewer/print","sourcesContent":["<template>\n  <div id=\"legend\">\n    <template v-for=\"(item, index) in layers\">\n      <div\n        :key=\"index\"\n        v-if=\"layerVisibility(item)\"\n        style=\"padding-right:10px;\"\n      >\n        <v-divider></v-divider>\n        <!-- LAYER TITLE -->\n        <p class=\"grey--text text--darken-2 pb-0 mb-1 mt-2 subtitle-2\">\n          {{\n            $te(`map.layerName.${item.get(\"name\")}`)\n              ? $t(`map.layerName.${item.get(\"name\")}`)\n              : item.get(\"name\")\n          }}\n        </p>\n        <!-- WMS LEGEND -->\n        <div v-if=\"item.get('legendGraphicUrl')\">\n          <img\n            crossorigin=\"anonymous\"\n            style=\"max-width:100%;\"\n            :src=\"item.get('legendGraphicUrl')\"\n            class=\"white--text mt-0 pt-0\"\n          />\n        </div>\n        <div v-else>\n          <div v-if=\"item.get('type') === 'WMS'\">\n            <template\n              v-for=\"(layerName, index2) in item\n                .getSource()\n                .getParams()\n                .LAYERS.split(',')\"\n            >\n              <div :key=\"index2\">\n                <img\n                  crossorigin=\"anonymous\"\n                  style=\"max-width:100%;\"\n                  :src=\"getWMSLegendImageUrl(item, layerName)\"\n                  class=\"white--text mt-0 pt-0\"\n                />\n                <br />\n              </div>\n            </template>\n          </div>\n          <!-- VECTOR LEGEND -->\n          <div v-if=\"['GEOBUF', 'MVT'].includes(item.get('type'))\">\n            <span\n              :ref=\"`legend-vector-${index}`\"\n              v-html=\"renderLegend(item, index)\"\n            ></span>\n          </div>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n<script>\nimport { mapGetters } from \"vuex\";\nimport { EventBus } from \"../../../EventBus\";\nimport { Mapable } from \"../../../mixins/Mapable\";\nimport { getWMSLegendURL } from \"../../../utils/Layer\";\nimport LegendRenderer from \"../../../utils/LegendRenderer\";\nimport { mapFields } from \"vuex-map-fields\";\n\nexport default {\n  mixins: [Mapable],\n  name: \"map-legend\",\n  props: {\n    color: { type: String, default: \"#2BB381\" }\n  },\n  data: () => ({\n    layers: [],\n    panel: [],\n    isMapMounted: false,\n    isRendered: false\n  }),\n  methods: {\n    /**\n     * This function is executed, after the map is bound (see mixins/Mapable)\n     */\n    onMapBound() {\n      const me = this;\n      const allLayers = me.map.getLayers().getArray();\n      me.layers = allLayers.filter(layer => {\n        return (\n          layer.get(\"displayInLegend\") !== false &&\n          layer.get(\"group\") !== \"basemap\"\n        );\n      });\n      this.isMapMounted = true;\n      EventBus.$on(\"openLegend\", () => this.panel.push(0));\n      EventBus.$on(\"closeLegend\", () => (this.panel = []));\n    },\n    getWMSLegendImageUrl(item, layerName) {\n      let layerUrl = item.getSource().getUrl();\n      if (layerUrl.startsWith(\"/\")) {\n        layerUrl = window.location.origin + layerUrl;\n      }\n      const style = item.getSource().getParams().STYLES;\n      const legedUrl = getWMSLegendURL(\n        layerUrl,\n        layerName,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        item.getSource().serverType_,\n        120,\n        undefined,\n        undefined,\n        undefined,\n        this.$i18n.locale,\n        style\n      );\n      return legedUrl;\n    },\n    renderLegend(item, index) {\n      this.$nextTick(() => {\n        const styleObj = this.vectorTileStyles;\n        const name = item.get(\"name\");\n        let styleTranslation = styleObj[name].translation || {};\n        const currentLocale = this.$i18n.locale;\n        if (styleObj[name] && styleObj[name].format === \"geostyler\") {\n          let el = this.$refs[`legend-vector-${index}`];\n          el = el ? el : [];\n          if (el.length) {\n            if (Array.isArray(el) && el.length > 0) {\n              el = el[0];\n            }\n            // Remove existing svg elements on update (Workaround)\n            if (el && el.childNodes.length > 0) {\n              el.removeChild(el.childNodes[0]);\n            }\n            const style = styleObj[name].style;\n            const filteredStyle = this.filterStylesOnActiveMode(style);\n\n            const renderer = new LegendRenderer({\n              maxColumnWidth: 240,\n              overflow: \"auto\",\n              styles: [filteredStyle || style],\n              size: [230, 300],\n              translation: { styleTranslation, currentLocale }\n            });\n            renderer.render(el);\n          }\n        }\n      });\n    },\n    filterStylesOnActiveMode(style) {\n      const styleRules = style.rules;\n      const filteredRules = [];\n      const activeMode = this.calculationMode.active;\n      let newStyle = { ...style };\n      if (Array.isArray(styleRules)) {\n        styleRules.forEach(rule => {\n          if (Array.isArray(rule.filter)) {\n            let showInLegend = true;\n            rule.filter.forEach(filter => {\n              /** FILTER CURRENT MODES. */\n              if (Array.isArray(filter) && filter.includes(\"modus\")) {\n                showInLegend = false;\n                const operator = filter[0];\n                const value = filter[2];\n                if (value === activeMode && operator === \"==\") {\n                  showInLegend = true;\n                } else if (value !== activeMode && operator === \"!=\") {\n                  showInLegend = true;\n                }\n              }\n            });\n            if (showInLegend) filteredRules.push(rule);\n            // Add all other rules in the legend\n          } else {\n            filteredRules.push(rule);\n          }\n        });\n        if (Array.isArray(filteredRules)) {\n          newStyle.rules = filteredRules;\n        }\n        return newStyle;\n      }\n    },\n    layerVisibility(item) {\n      if (\n        (this.map.getView().getResolution() <= item.get(\"maxResolution\") &&\n          item.getVisible() === true &&\n          item.get(\"displayInLayerList\") !== false &&\n          item.get(\"displayInLegend\") !== false &&\n          item.get(\"group\") !== \"backgroundLayers\" &&\n          this.isMapMounted === true &&\n          this.vectorTileStyles) ||\n        item.get(\"name\") == \"study_area_crop\"\n      ) {\n        return true;\n      }\n      return false;\n    }\n  },\n\n  computed: {\n    ...mapGetters(\"app\", {\n      calculationMode: \"calculationMode\"\n    }),\n    ...mapFields(\"map\", {\n      vectorTileStyles: \"vectorTileStyles\"\n    })\n  },\n  watch: {\n    \"calculationMode.active\": function() {\n      this.$forceUpdate();\n    }\n  }\n};\n</script>\n<style lang=\"css\" scoped>\n.v-expansion-panel-header {\n  min-height: 30px;\n  padding: 5px;\n}\n\n.v-expansion-panel-content >>> .v-expansion-panel-content__wrap {\n  padding: 2px 0px 0px 5px;\n}\n</style>\n"]}]}